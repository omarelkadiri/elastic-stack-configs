input {
  beats {
    port => 5044
    ssl_enabled => true
    ssl_certificate => "/etc/logstash/certs/logstash.crt"
    ssl_certificate_authorities => ["/etc/logstash/certs/ca.crt"]
    ssl_key => "/etc/logstash/certs/logstash.pkcs8.key"
    ssl_verify_mode => "force_peer"
    add_field => { "[@metadata][type]" => "packetbeat" }
  }
  tcp {
    port => 514
    add_field => { "[@metadata][type]" => "syslog" }
  }
}

filter {
  if [@metadata][beat] == "packetbeat" {

      #mutate {
        #add_field => { "log_type" => "packetbeat" }
      #}

  }
  else if [@metadata][type] == "syslog" {
    # Filtre pour les logs Syslog
    grok {
      match => { "message" => [
        "<%{INT:PRI}>%{SYSLOGTIMESTAMP:timestamp} %{SYSLOGHOST:[host][hostname]} %{DATA:process.name}\[%{POSINT:pid}\]: %{POSINT:[rule_id]} , %{DATA:[info1]} , %{DATA:[info2]} , %{NOTSPACE:[id_section]} , %{WORD:[interface]} , %{WORD:[corresp]} , %{WORD:[action]} , %{WORD:[direction]} , %{POSINT:[network][ipv]} , %{WORD:[packet][tos]} , %{DATA:add_field} , %{POSINT:[packet][ttl]} , %{NUMBER:[packet][id_packet]} , %{DATA:[packet][offset]} , %{WORD:[packet][flags]} , %{POSINT:[network][protocol_num]} , %{WORD:[network][transport]} , %{NUMBER:[network][bytes]} , %{IPV4:[source][ip]} , %{IPV4:[destination][ip]} , %{INT:[source][port]} , %{INT:[destination][port]} , %{GREEDYDATA:more_data}",
        "<%{INT:PRI}>%{SYSLOGTIMESTAMP:timestamp} %{SYSLOGHOST:[host][hostname]} %{DATA:process.name}\[%{POSINT:pid}\]: %{POSINT:[rule_id]} , %{DATA:[info1]} , %{DATA:[info2]} , %{NOTSPACE:[id_section]} , %{WORD:[interface]} , %{WORD:[corresp]} , %{WORD:[action]} , %{WORD:[direction]} , %{POSINT:[network][ipv]} , %{WORD:[packet][flags]} , %{WORD:[packet][tos]} , %{POSINT:[packet][ttl]} , %{WORD:[network][transport]} , %{POSINT:[network][size_header]} , %{NUMBER:[network][bytes]} , %{IPV6:[source][ip]} , %{IPV6:[destination][ip]} , %{INT:[source][port]} , %{INT:[destination][port]} , %{GREEDYDATA:more_data}",
        "<%{INT:PRI}>%{SYSLOGTIMESTAMP:timestamp} %{SYSLOGHOST:[host][hostname]} %{DATA:process.name}\[%{POSINT:pid}\]: %{POSINT:[rule_id]} , %{DATA:[info1]} , %{DATA:[info2]} , %{NOTSPACE:[id_section]} , %{WORD:[interface]} , %{WORD:[corresp]} , %{WORD:[action]} , %{WORD:[direction]} , %{POSINT:[network][ipv]} , %{WORD:[packet][tos]} , %{DATA:add_field} , %{POSINT:[packet][ttl]} , %{NUMBER:[packet][id_packet]} , %{DATA:[packet][offset]} , %{WORD:[packet][flags]} , %{POSINT:[network][protocol_num]} , %{WORD:[network][transport]} , %{NUMBER:[network][bytes]} , %{IPV4:[source][ip]} , %{IPV4:[destination][ip]} , %{GREEDYDATA:more_data}",
        "<%{INT:PRI}>%{SYSLOGTIMESTAMP:timestamp} %{SYSLOGHOST:[host][hostname]} %{WORD:process.name}\[%{POSINT:pid}\]: user %{USERNAME:user} %{GREEDYDATA:result} for %{WORD:service}\.? \[using %{GREEDYDATA:auth_method}\]",
        "<%{INT:PRI}>%{SYSLOGTIMESTAMP:timestamp} %{SYSLOGHOST:[host][hostname]} %{WORD:process.name}\[%{POSINT:pid}\]: %{GREEDYDATA:[action]} for user '%{USERNAME:user}' from: %{IPV4:[source][ip]}"
      ] }
    }
    date {
      match => [ "timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
    }

    mutate {
      add_field => { "[agent][type]" => "syslog" }
    }
    
    if not "_grokparsefailure" in [tags] {
      mutate { add_field => { "[@metadata][index_name]" => "network-logs-%{[@metadata][type]}" } }
    }
    else {
      mutate { add_field => { "[@metadata][index_name]" => "more-logs" } }
    }
    
  }

  # Filtre commun pour les logs Packetbeat et Syslog
  mutate {
    lowercase => [ "[host][hostname]", "[agent][type]" ]
    convert => { "response_code" => "integer" }
  }
}

output {
  elasticsearch {
    hosts => ["https://node1.elastic.test.com:9200"]
    ssl => true
    cacert => "/etc/logstash/certs/ca.crt"
    user => "elastic"  
    password => "789632145"  
    index => "%{[@metadata][index_name]}-%{+YYYY.MM.dd}"
  }
  stdout { codec => rubydebug }
}

